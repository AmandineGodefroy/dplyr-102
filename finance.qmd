---
title: "Financial data analysis"
author: "Amandine Godefroy"
format: html
---

```{r}
#| message: false
#| warning: false
here::i_am("dplyr-102.Rproj")
library(here)
library(vroom) ## or readr
library(tidyr)
library(dplyr)
library(ggplot2)
library(patchwork)
```

## Data loading
```{r}
#| message: false
clients <- vroom(here("data", "client.csv"))
accounts <- vroom(here("data", "account.csv"))
disp <- vroom(here("data", "disp.csv"))
```

## Joining data tables
A collection of joining functions of the form "_join".

### Inner join (a natural join)
Merge deux databases avec un même identifiant (pour même valeurs communes, all the a values of the first dataset combines with the b values from the other dataset). In the new dataset all the values appears only once. 
```{r}
da <- inner_join(accounts, disp)
```
On joint à cette nvelle base la base clients en précisant par quel id merger ces deux bases pour s'assurer du bon appariement (puisque les deux "district_id" diffèrent entres les bases)--> "join_by".

"suffix" permet de différencier les variables provenant des deux bases (home pour clients et bank pour da).

```{r}
cda <- inner_join(clients, da, by=join_by(client_id),suffix=c("_home","_bank"))
```

### home district versus bank district
vérification des données qui diffèrent (exclues si pas de "join_by")
!= means different
```{r}
cda |> filter(district_id_home != district_id_bank)
```
```{r}
home_diff_bank <- cda |>
  filter(district_id_home != district_id_bank) |>
  nrow()
```
We observe taht `r home_diff_bank` clients have a bank in another district as the one they live in.

We will now compare by row the persons.
How many diff districts are attached to all the groups ?
```{r}
cda |>
  group_by(account_id) |>
  distinct(district_id_home) |>
  summarize(N = n()) |>
  filter(N > 1)
```
### Gender gap ?

```{r}
clients |>
  count(gender)
```
Graphique en bar vertical
```{r}
clients |> ggplot(aes(x=gender)) + geom_bar()
```
Graphique en bar horizontal
```{r}
clients |> ggplot(aes(x=gender)) + geom_bar() + coord_flip()
```
```{r}
cda |>
  count(gender, type) |>
  group_by(gender) |>
  mutate(freq = n / sum(n)) |>
  select(-n) |>
  pivot_wider(values_from = freq, names_from = type)
```
display graphically on the way it account
```{r}
cda |> ggplot(aes(y = gender, fill = type)) +
  geom_bar(position = "fill")
```
we see a strong dependancy
we can also do a chi2 test
In the dataset we do not see a strong effect of sex on the type of account.
```{r}
chisq.test(cda |> pull(gender), cda |> pull(type))
```
we cannot reject the hypothesis

## Loan analysis

```{r}
#| message: false
loan <- vroom(here("data","loan.csv"))
```

```{r}
loan <- loan |>
  mutate(status = factor(status, levels=c("A","B","C","D")),
         account_id = as.integer(account_id),
         loan_id = as.integer(loan_id))
```
avant status était perçu comme caractère et maintenant comme facteur.

Factor recoding of `status` introduced `r loan |> filter(is.na(status)) |> nrow() ` error(s).


```{r}
# distribution of discrete variable -> bar graph
loan_counts <- ggplot(loan, aes(x=status)) + geom_bar()

print(loan_counts)
```

```{r}
# computate an aggregate based on the status of the loan
loan |>
  group_by(status) |>
  summarise(sum(amount))
```
Rep graph : amount condition on the status
```{r}
ggplot(loan, aes(x = status, y = amount)) +
  geom_boxplot()
```
defaults are associated to big loans but are they any causal factors?

Representation graph of the table above
```{r}
# compute what we want to display + use of graphical primitives

loan_amounts <- loan |> 
  group_by(status) |>
  summarise("total amount" = sum(amount)) |>
  ggplot(aes(x=status, y=`total amount`)) +
  geom_col()
```

To put the two graph representation side by side -> use of the patchwork package
```{r}
loan_counts + loan_amounts
```
graphiques à l'horizontal
```{r}
(loan_counts + coord_flip()) / (loan_amounts + coord_flip())
```

```{r}
(loan |> 
  filter(status %in% c("A","B")) |>
  ggplot(aes(x=status)) + geom_bar()) + # + from patchwork
(loan |>
  filter(status %in% c("C","D")) |>
  ggplot(aes(x=status)) + geom_bar())
```
```{r}
# current loans vs past loans -> mutate to create a new column

loan <- loan |> 
  mutate(active = if_else(status %in% c("A","B"), "Past", "Active"))
```

```{r}
ggplot(loan, aes(x = status)) +
  geom_bar() +
  facet_wrap(~active)
```
we want the wcale dependant on the facet (here there are empty colums)
```{r}
ggplot(loan, aes(x = status)) +
  geom_bar() +
  facet_wrap(~active, scale = "free")
```
```{r}
loan |> ggplot(aes(y=active, fill=status))+geom_bar(position = "fill")

# postition = "fill" to have conditional distribution
```
```{r}
loan <- loan |>
  mutate(default = status %in% c("B","D"))
```
```{r}
ggplot(loan, aes(y=active, fill=default))+geom_bar(position = "fill")

```

